#!/usr/bin/env python3
#
#////////////////////////////////////////////////////////////////////////
#                                                                       #
#                                 buildGEO.py                           # 
#                                                                       #
#////////////////////////////////////////////////////////////////////////
#
# Author:     Edwin
# 
# Date:       July 8, 2019
#
# Modified:   July 10, 2019
#
# Works on:   python3
#
# Purpose:    Script takes in a CSV file generated from SHP2GEO.py script 
#             of a geometry and produces a geometry file (GEO) used by 
#             gmsh.
#
# Needs:      Python3, csv, sys, os, shutil
#
# Usage:      python3 buildGEO.py <mode> <input.csv> <output.geo>
#
# where:
# --> mode: a string that defines how the script will behave according 
#           to the type of geometry that will be built.
#
#     --> b: uses a CSV file generated by the p mode in SHP2GEO.py and
#            creates a new GEO file. It reads the fields "X_m","Y_m",
#            as coordinates, "Z_m" is set to 0 (since we need a 2D mesh)
#            and the element size from "R_m". At the end, a plane surface
#            defining the computational domain is given. 
#
#     --> l: uses a CSV file generated by the l mode in SHP2GEO.py and
#            appends to output GEO file. It reads the fields "X_m","Y_m",
#            as coordinates, "Z_m" is set to 0 (since we need a 2D mesh)
#            and the element size from "R_m". At the end, a list of hard 
#            lines on the plane surface (computational domain) is added
#            at the end of the GEO file.
#
#     --> p: uses a CSV file generated by the v mode in SHP2GEO.py and
#            appends to output GEO file. It reads the fields "X_m","Y_m",
#            as coordinates, "Z_m" is set to 0 (since we need a 2D mesh)
#            and the element size from "R_m". At the end, a list of hard 
#            points on the plane surface (computational domain) is added
#            at the end of the GEO file.
# 
# --> input.csv: a string that defines the path to CSV file from where the
#                geometry will be read.
#
# --> output.geo: a string that defines the path to the GEO file where the 
#                 geometrical entities will be written.                       
#
# Bibliography & Useful links:
# -- http://gmsh.info/doc/texinfo/gmsh.html#Points
# -- https://github.com/pprodano/pputils
#
#////////////////////////////////////////////////////////////////////////

import csv, sys, os, shutil

#import own functions 
import fily, gis, gets, build


#Retrieve path of files from the arguments passed to the script
pathToCSVFile = str(sys.argv[2])            #CSV  input file 
pathToGEOFile = str(sys.argv[3])            #GEO output file

# Field names for the different attributes of the points given on the
#  CSV inputFile
xColumnID = "X_m"                       # X-Coordinate
yColumnID = "Y_m"                       # Y-Coordinate
iColumnID = "vertex_ind"                # Point Identification
holeColID = "vertex_par"                # Ring Identification
paragraphSeparator = ["\n","/**********************************/"]

### Retrieves GEO builder mode
#### b | polygon         : computational domain boundary
#### p | points          : fixed points on the computational domain
#### l | lines           : breaklines on the computational domain
execMode = str(sys.argv[1]).lower()

#Extract X-coordinates as a list
xCoord = gets.getCommaFile(pathToCSVFile,col=gets.getColumn(xColumnID,pathToCSVFile))
xCoord.remove(xColumnID)

#Extract Y-coordinates as a list
yCoord = gets.getCommaFile(pathToCSVFile,col=gets.getColumn(yColumnID,pathToCSVFile))
yCoord.remove(yColumnID)

#Extract Z-coordinates as a list [ Just a list of zeros ]
zCoord = ["0.00"] * (len(xCoord))

#////////////////////////////////////////////////////////////////////////

if execMode in ["-b", "--boundary"]:
    #This mode OVERWRITES a list of points as boundaries of a computational
    #   domain. The other execMode's APPEND to the GEO file.

    rColumnID = "Rx_m"    #if the boundary was obtained as SHP2GEO h mode
                          #  change to "R_m" if the b mode was used 
    
    #Extract identification of points as a list
    iCoord = gets.getCommaFile(pathToCSVFile,col=gets.getColumn(iColumnID,pathToCSVFile))
    iCoord.remove(iColumnID)
    
    #Extract element size values as a list
    rCoord = gets.getCommaFile(pathToCSVFile,col=gets.getColumn(rColumnID,pathToCSVFile))
    rCoord.remove(rColumnID)

    #Extract hole indentifications as a list
    holeCol = gets.getCommaFile(pathToCSVFile,col=gets.getColumn(holeColID,pathToCSVFile))
    holeCol.remove(holeColID)
    
    #Initialize GEO file. In this mode the GEO file is written from scratch
    fily.resetFile(pathToGEOFile,"GEO")
    
    #Identify rings on the computational domain
    holeListID = list(set(holeCol))
    holeListID.sort()
    
    holeIndex = []
    for hole in holeListID :
        holeIndex.append(holeCol.index(hole))
    holeIndex.append(len(holeCol))

    #Build an independent polygon for each ring found on the topology 
    for hole in range(len(holeListID)) :
        # Construction of "Point()" GEO-features 
        start = holeIndex[hole]
        end   = holeIndex[hole+1]-1
        GEO_Points = build.buildGEOPoints( \
            xCoord[start:end],\
            yCoord[start:end],\
            zCoord[start:end],\
            iCoord[start:end],\
            rCoord[start:end]\
                )
        fily.appendFile(GEO_Points,pathToGEOFile)
        
        # Construction of "Line()" GEO-features 
        LINES1 = list(iCoord[start:end])
        LINES2 = list((iCoord[start+1:end]))+[iCoord[start]]
        INDEXLINES = list(range(start,end))
        GEO_Lines = build.buildGEOLines(INDEXLINES,LINES1,LINES2)
        fily.appendFile(GEO_Lines,pathToGEOFile)

        # Construction of "Line Loop()" GEO-features 
        GEO_Loops = ["\nLine Loop (LL+" + \
            str(hole) + ") = {L+" + \
            str(min(INDEXLINES)) + " ... L+" +  \
            str(max(INDEXLINES)) + "};"\
                ]
        fily.appendFile(GEO_Loops,pathToGEOFile)
        fily.appendFile(paragraphSeparator,pathToGEOFile)

    # Construction of "Plane Surface()" GEO-feature. Only one is required to 
    #   define the whole computational domain. 
    GEO_Surface = ["Plane Surface (PS+1) = {LL+" + \
        str(min(iCoord)) + " ... " + "LL+" + \
        str(len(holeListID)-1) + "};\n"\
            ]
    fily.appendFile(GEO_Surface,pathToGEOFile)
    
    # Update indeces starting point
    fily.appendFile(paragraphSeparator,pathToGEOFile)
    fily.appendFile(build.addLastIndex("P",str(len(xCoord)),True),pathToGEOFile,True)
    fily.appendFile(build.addLastIndex("L",str(max(INDEXLINES)),True),pathToGEOFile,True)
    fily.appendFile(build.addLastIndex("L",str(1),True),pathToGEOFile,True)
    fily.appendFile(build.addLastIndex("LL",str(hole),True),pathToGEOFile,True)
    fily.appendFile(build.addLastIndex("PS",str(len(GEO_Surface)),True),pathToGEOFile,True)
    fily.appendFile(paragraphSeparator,pathToGEOFile)

    print("Computational Domain ~OK~: " + str(sys.argv[2]) + " > " + str(sys.argv[3]))

elif execMode in ["-p", "--pointsinsurface"]:
    #This mode APPENDS a list of points as hard points into a previously
    #   generated boundary from the buildGEO.py "b" mode.
    
    rColumnID = "R_m"   #if the boundary was obtained as SHP2GEO "v" mode
                              
    #Extract element size values as a list
    rCoord = gets.getCommaFile(pathToCSVFile,col=gets.getColumn(rColumnID,pathToCSVFile))
    rCoord.remove(rColumnID)
    
    #Overwrite point indices
    iCoord = list(range(len(xCoord)))

    # Construction of "Point()" GEO-features
    GEO_Points = build.buildGEOPoints(xCoord,yCoord,zCoord,iCoord,rCoord)
    fily.appendFile(GEO_Points,pathToGEOFile)

    # Construction of "Point in Surface" GEO-features
    GEO_PointsInSurface = ["Point {P+1 ... P+" + str(max(iCoord)) +\
        "} In Surface { 1 } ;\n"]
    fily.appendFile(GEO_PointsInSurface,pathToGEOFile)
    
    # Update indeces starting point
    fily.appendFile(paragraphSeparator,pathToGEOFile)
    fily.appendFile(build.addLastIndex("P",str(len(GEO_Points)),True),pathToGEOFile,True)
    fily.appendFile(paragraphSeparator,pathToGEOFile)
    print("Hardpoints ~OK~: " + str(sys.argv[2]) + " > " + str(sys.argv[3]))

elif execMode in ["-l", "--linesinsurface"]:
    
    #This mode APPENDS a list of points as hard points into a previously
    #   generated boundary from the buildGEO.py "b" mode.
    
    lineColID = "DN"               #Should be inputed by the user but meh
    rColumnID = "R_m"              #if the boundary was obtained as SHP2GEO l mode
 
    #Extract element size values as a list
    rCoord = gets.getCommaFile(pathToCSVFile,col=gets.getColumn(rColumnID,pathToCSVFile))
    rCoord.remove(rColumnID)

    #Extract identification of points as a list
    iCoord = gets.getCommaFile(pathToCSVFile,col=gets.getColumn(iColumnID,pathToCSVFile))
    iCoord.remove(iColumnID)

    #Extract different line identifiers values as a list
    lineCol = gets.getCommaFile(pathToCSVFile,col=gets.getColumn(lineColID,pathToCSVFile))
    lineCol.remove(lineColID)
    
    #Get a list of unique line identifiers and the lines in the CSV file
    #   where they start and end
    lineListID = build.setColumn(lineCol)
    lineIndex = []
    for line in lineListID :
        lineIndex.append(lineCol.index(line))
    lineIndex.append(len(lineCol))
    
    #Build an independent line for each line found on the CSV file
    for line in range(len(lineListID)) :
        
        # Construction of "Point()" GEO-features
        start = lineIndex[line]
        end   = lineIndex[line+1] 
        GEO_Points = build.buildGEOPoints( \
            xCoord[start:end],\
            yCoord[start:end],\
            zCoord[start:end],\
            iCoord[start:end],\
            rCoord[start:end]\
                )
        fily.appendFile(GEO_Points,pathToGEOFile)
        
        # Construction of "Point()" GEO-features
        LINES1 = list(iCoord[start:end-1])
        LINES2 = list(iCoord[start+1:end])
        INDEXLINES = list(iCoord[start:end-1])
        GEO_Lines = build.buildGEOLines(INDEXLINES,LINES1,LINES2)
        fily.appendFile(GEO_Lines,pathToGEOFile)

        # Construction of "Line in Surface" GEO-features
        GEO_LinesInSurface = ["Line {L+" + \
            str(INDEXLINES[0]) + \
            " ... L+" + \
            str(INDEXLINES[-1]) +\
            "} In Surface { 1 } ;\n"]
        fily.appendFile(GEO_LinesInSurface,pathToGEOFile)
    
        # Update indeces starting point
        fily.appendFile(paragraphSeparator,pathToGEOFile)
        fily.appendFile(build.addLastIndex("P",str(INDEXLINES[-1]),True),pathToGEOFile,True)
        fily.appendFile(build.addLastIndex("P",str(2),True),pathToGEOFile,True)
        fily.appendFile(build.addLastIndex("L",str(INDEXLINES[-1]),True),pathToGEOFile,True)
        fily.appendFile(build.addLastIndex("L",str(1),True),pathToGEOFile,True)
        fily.appendFile(paragraphSeparator,pathToGEOFile)
    print("Hardlines ~OK~: " + str(sys.argv[2]) + " > " + str(sys.argv[3]))
    
fily.appendFile("//END OF BLOCK//\n\n\n",pathToGEOFile,True)
