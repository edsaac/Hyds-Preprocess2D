#
#////////////////////////////////////////////////////////////////////////
#                                                                       #
#                                 buildGEO.py                           # 
#                                                                       #
#////////////////////////////////////////////////////////////////////////
#
# Author:     Edwin
# 
# Date:       July 8, 2019
#
# Modified:   July 10, 2019
#
# Works on:   python3
#
# Purpose:    Script takes in a CSV file generated from SHP2GEO.py script 
#             of a geometry and produces a geometry file (GEO) used by 
#             gmsh.
#
# Needs:      Python3, csv, sys, os, shutil
#
# Usage:      python3 buildGEO.py <mode> <input.csv> <output.geo>
#
# where:
# --> mode: a string that defines how the script will behave according 
#           to the type of geometry that will be built.
#
#     --> b: uses a CSV file generated by the p mode in SHP2GEO.py and
#            creates a new GEO file. It reads the fields "X_m","Y_m",
#            as coordinates, "Z_m" is set to 0 (since we need a 2D mesh)
#            and the element size from "R_m". At the end, a plane surface
#            defining the computational domain is given. 
#
#     --> l: uses a CSV file generated by the l mode in SHP2GEO.py and
#            appends to output GEO file. It reads the fields "X_m","Y_m",
#            as coordinates, "Z_m" is set to 0 (since we need a 2D mesh)
#            and the element size from "R_m". At the end, a list of hard 
#            lines on the plane surface (computational domain) is added
#            at the end of the GEO file.
#
#     --> p: uses a CSV file generated by the v mode in SHP2GEO.py and
#            appends to output GEO file. It reads the fields "X_m","Y_m",
#            as coordinates, "Z_m" is set to 0 (since we need a 2D mesh)
#            and the element size from "R_m". At the end, a list of hard 
#            points on the plane surface (computational domain) is added
#            at the end of the GEO file.
# 
# --> input.csv: a string that defines the path to CSV file from where the
#                geometry will be read.
#
# --> output.geo: a string that defines the path to the GEO file where the 
#                 geometrical entities will be written.                       
#
# Bibliography & Useful links:
# -- http://gmsh.info/doc/texinfo/gmsh.html#Points
# -- https://github.com/pprodano/pputils
#
#////////////////////////////////////////////////////////////////////////

import csv, sys, os, shutil

#Retrieve path of files from the arguments passed to the script
pathToCSVFile = str(sys.argv[2])            #CSV  input file 
pathToGEOFile = str(sys.argv[3])            #GEO output file

#////////////////////////////////////////////////////////////////////////
#                         def Functions                                 #
#////////////////////////////////////////////////////////////////////////

###   Reads a CSV file and returns a whole row, a whole column or a
###     single item
def getCommaFile(fileName, row = -1, col= -1):
    #Reads the CSV file from the given path
    while True:
        try: 
            rawPointFile = open(fileName)
            rawPointFile = list(csv.reader(rawPointFile))
            break
        except FileNotFoundError:
            print("CSV file could not be found")

    #Returns a single row of the CSV file
    while row != -1 and col == -1:
        try:
            return rawPointFile[row]
        except IndexError:
            print("Row could not be found")

    #Return a single column of the CSV file
    while row == -1 and col != -1:
        try:
            colFile=[]
            for row in range(len(rawPointFile)):
                colFile.append(rawPointFile[row][col])
            return colFile
        except IndexError:
            print("Column could not be found")

    #Return a single value of the CSV file
    while row != -1 and col != -1:
        try:
            return rawPointFile[row][col]
        except IndexError:
            print("Item could not be found")

###   From the CSV headers identifies the position of certain attribute
def getColumn(xID,fileName = pathToCSVFile):
    try:
        header = getCommaFile(fileName,row=0)
        return(header.index(xID))
    except ValueError:
        print(str(xID) + " column could not be found")

###   Starts a new GEO file with initialization of indeces of the GEO 
###     features 
def resetFile(nameFile):
    with open(nameFile,"w") as outFile:
        outFile.write('P=1;\nL=1;\nLL=1;\nPS=0;\n\n')
        outFile.close()

###   Appends to a GEO file a list of features 
def appendFile(appendy, nameFile = pathToGEOFile):
    with open(nameFile,"a") as outFile:
        for i in range(len(appendy)):
            outFile.write(str(appendy[i]))
        outFile.close()

###   Builds the "Point()" GEO features from a list of X-coordinates, 
###     Y-coordinates, Z-coordinates, indices and element sizes  
def buildGEOPoints(X,Y,Z=[],I=[],R=[]):
    ligne=['']
    for item in range(len(X)):
        i1 = int(I[item])
        x1 = float(X[item])
        y1 = float(Y[item])
        z1 = float(Z[item])
        r1 = float(R[item])
        ligne.append("Point(P+" + str(i1) + ") = {" \
                 + str(x1) +\
             "," + str(y1) +\
             "," + str(z1) +\
             "," + str(r1) + "};" + '\n'
                 )
    return ligne

###   Builds the "Line()" GEO features from a list of Start-Points,
###     End-Points and indices
def buildGEOLines(I,L1,L2):
    ligne=['']
    for item in range(len(I)):
        i1 = int(I[item])
        l1 = int(L1[item])
        l2 = int(L2[item])
        ligne.append("Line(L+" + str(i1) + ") = {P+" \
                    + str(l1) +\
             ", P+" + str(l2) + "};" + '\n'
                 )
    return ligne

###   Add a line to the GEO file setting the new start value for the
###     GEO indices of certain feature
def addLastIndex(parameter, quantity = 0, recursive = False):
    if recursive == False:
        indicator = str(parameter) + " = " + str(quantity) + ";\n" 
        appendFile(indicator)
    else:
        indicator = str(parameter) + " = " + str(parameter) + " + " + str(quantity) + ";\n" 
        appendFile(indicator)
    return

###   From a list of data, extracts a list of features without repetitions
###     e.g., [0,1,1,2,2,3] >> [0,1,2,3]
###     It works as set() but keeps the order of the elements on the original list
def setColumn(column):
    result = []
    k = 0
    for i in range(len(column)):
        if column[i] not in result :
            result.append(column[i])
            k+=1
    return result

#////////////////////////////////////////////////////////////////////////

# Field names for the different attributes of the points given on the
#  CSV inputFile
xColumnID = "X_m"                       # X-Coordinate
yColumnID = "Y_m"                       # Y-Coordinate
iColumnID = "vertex_ind"                # Point Identification
holeColID = "vertex_par"                # Ring Identification
paragraphSeparator = ['\n',"/**********************************/",'\n\n']

### Retrieves GEO builder mode
#### b | polygon         : computational domain boundary
#### p | points          : fixed points on the computational domain
#### l | lines           : breaklines on the computational domain
execMode = str(sys.argv[1]).lower()

#Extract X-coordinates as a list
xCoord = getCommaFile(pathToCSVFile,col=getColumn(xColumnID))
xCoord.remove(xColumnID)

#Extract Y-coordinates as a list
yCoord = getCommaFile(pathToCSVFile,col=getColumn(yColumnID))
yCoord.remove(yColumnID)

#Extract Z-coordinates as a list [ Just a list of zeros ]
zCoord = list(range(len(xCoord)))
for i in range(len(zCoord)):
    zCoord[i] = float(zCoord[i])*0
zCoord = list(zCoord)

#Extract identification of points as a list
iCoord = getCommaFile(pathToCSVFile,col=getColumn(iColumnID))
iCoord.remove(iColumnID)

#////////////////////////////////////////////////////////////////////////

if execMode in ["b", "boundary"]:
    #This mode OVERWRITES a list of points as boundaries of a computational
    #   domain. The other execMode's APPEND to the GEO file.

    rColumnID = "Rx_m"    #if the boundary was obtained as SHP2GEO h mode
                          #  change to "R_m" if the b mode was used 

    #Extract element size values as a list
    rCoord = getCommaFile(pathToCSVFile,col=getColumn(rColumnID))
    rCoord.remove(rColumnID)

    #Extract hole indentifications as a list
    holeCol = getCommaFile(pathToCSVFile,col=getColumn(holeColID))
    holeCol.remove(holeColID)
    
    #Initialize GEO file. In this mode the GEO file is written from scratch
    resetFile(pathToGEOFile)
    
    #Identify rings on the computational domain
    holeListID = list(set(holeCol))
    holeListID.sort()
    
    holeIndex = []
    for hole in holeListID :
        holeIndex.append(holeCol.index(hole))
    holeIndex.append(len(holeCol))

    #Build an independent polygon for each ring found on the topology 
    for hole in range(len(holeListID)) :
        # Construction of "Point()" GEO-features 
        start = holeIndex[hole]
        end   = holeIndex[hole+1]-1
        GEO_Points = buildGEOPoints( \
            xCoord[start:end],\
            yCoord[start:end],\
            zCoord[start:end],\
            iCoord[start:end],\
            rCoord[start:end]\
                )
        appendFile(GEO_Points)
        
        # Construction of "Line()" GEO-features 
        LINES1 = list(iCoord[start:end])
        LINES2 = list((iCoord[start+1:end]))+[iCoord[start]]
        INDEXLINES = list(range(start,end))
        GEO_Lines = buildGEOLines(INDEXLINES,LINES1,LINES2)
        appendFile(GEO_Lines)

        # Construction of "Line Loop()" GEO-features 
        GEO_Loops = ["Line Loop (LL+" + \
            str(hole) + ") = {L+" + \
            str(min(INDEXLINES)) + " ... L+" +  \
            str(max(INDEXLINES)) + "};\n"\
                ]
        appendFile(GEO_Loops)
        appendFile(paragraphSeparator)

    # Construction of "Plane Surface()" GEO-feature. Only one is required to 
    #   define the whole computational domain. 
    GEO_Surface = ["Plane Surface (PS+1) = {LL+" + \
        str(min(iCoord)) + " ... " + "LL+" + \
        str(len(holeListID)-1) + "};\n"\
            ]
    appendFile(GEO_Surface)
    
    # Update indeces starting point
    appendFile(paragraphSeparator)
    addLastIndex("P",str(len(xCoord)),True)
    addLastIndex("L",str(max(INDEXLINES)),True)
    addLastIndex("L",str(1),True)
    addLastIndex("LL",str(hole),True)
    addLastIndex("PS",str(len(GEO_Surface)),True)
    appendFile(paragraphSeparator)

    print("Computational Domain ~OK~")

elif execMode in ["p", "pointsinsurface"]:
    #This mode APPENDS a list of points as hard points into a previously
    #   generated boundary from the buildGEO.py "b" mode.
    
    rColumnID = "R_m"   #if the boundary was obtained as SHP2GEO "v" mode
                              
    #Extract element size values as a list
    rCoord = getCommaFile(pathToCSVFile,col=getColumn(rColumnID))
    rCoord.remove(rColumnID)
    
    # Construction of "Point()" GEO-features
    GEO_Points = buildGEOPoints(xCoord,yCoord,zCoord,iCoord,rCoord)
    appendFile(GEO_Points)

    # Construction of "Point in Surface" GEO-features
    GEO_PointsInSurface = ["Point {P+1 ... P+" + str(max(iCoord)) +\
        "} In Surface { 1 } ;\n"]
    appendFile(GEO_PointsInSurface)
    
    # Update indeces starting point
    appendFile(paragraphSeparator)
    addLastIndex("P",str(len(GEO_Points)),True)
    appendFile(paragraphSeparator)

elif execMode in ["l", "linesinsurface"]:
    
    #This mode APPENDS a list of points as hard points into a previously
    #   generated boundary from the buildGEO.py "b" mode.
    
    lineColID = "DN"               #Should be inputed by the user but meh
    rColumnID = "R_m"              #if the boundary was obtained as SHP2GEO l mode
 
    #Extract element size values as a list
    rCoord = getCommaFile(pathToCSVFile,col=getColumn(rColumnID))
    rCoord.remove(rColumnID)

    #Extract different line identifiers values as a list
    lineCol = getCommaFile(pathToCSVFile,col=getColumn(lineColID))
    lineCol.remove(lineColID)
    
    #Get a list of unique line identifiers and the lines in the CSV file
    #   where they start and end
    lineListID = setColumn(lineCol)
    lineIndex = []
    for line in lineListID :
        lineIndex.append(lineCol.index(line))
    lineIndex.append(len(lineCol))
    
    #Build an independent line for each line found on the CSV file
    for line in range(len(lineListID)) :
        
        # Construction of "Point()" GEO-features
        start = lineIndex[line]
        end   = lineIndex[line+1] 
        GEO_Points = buildGEOPoints( \
            xCoord[start:end],\
            yCoord[start:end],\
            zCoord[start:end],\
            iCoord[start:end],\
            rCoord[start:end]\
                )
        appendFile(GEO_Points)
        
        # Construction of "Point()" GEO-features
        LINES1 = list(iCoord[start:end-1])
        LINES2 = list(iCoord[start+1:end])
        INDEXLINES = list(iCoord[start:end-1])
        GEO_Lines = buildGEOLines(INDEXLINES,LINES1,LINES2)
        appendFile(GEO_Lines)

        # Construction of "Line in Surface" GEO-features
        GEO_LinesInSurface = ["Line {L+" + \
            str(INDEXLINES[0]) + \
            " ... L+" + \
            str(INDEXLINES[-1]) +\
            "} In Surface { 1 } ;\n"]
        appendFile(GEO_LinesInSurface)
    
        # Update indeces starting point
        appendFile(paragraphSeparator)
        addLastIndex("P",str(INDEXLINES[-1]),True)
        addLastIndex("P",str(2),True)
        addLastIndex("L",str(INDEXLINES[-1]),True)
        addLastIndex("L",str(1),True)
        appendFile(paragraphSeparator)
    
appendFile("//END OF BLOCK//\n\n\n")
print("buildGEO Job ~OK~")