#
#////////////////////////////////////////////////////////////////////////
#                                                                       #
#                                 buildGEO.py                           # 
#                                                                       #
#////////////////////////////////////////////////////////////////////////
#
# Author:     Edwin
# 
# Date:       July 8, 2019
#
# Modified:   July 8, 2019
#
# Works on:   python3
#
# Purpose:    Script takes in a CSV file generated from SHP2GEO.py script 
#             of a geometry and produces a geometry file (GEO) used by 
#             gmsh.
#
# Needs:      Python3, csv, sys, os, shutil
#
# Usage:      python3 buildGEO.py <mode> <input.csv> <output.geo>
#
# where:
# --> mode: a string that defines how the script will behave according 
#           to the type of geometry that will be built.
#
#     --> b: uses a CSV file generated by the p mode in SHP2GEO.py and
#            creates a new GEO file. It reads the fields "X_m","Y_m",
#            as coordinates, "Z_m" is set to 0 (since we need a 2D mesh)
#            and the element size from "R_m". At the end, a plane surface
#            defining the computational domain is given. 
#
#     --> l: uses a CSV file generated by the l mode in SHP2GEO.py and
#            appends to output GEO file. It reads the fields "X_m","Y_m",
#            as coordinates, "Z_m" is set to 0 (since we need a 2D mesh)
#            and the element size from "R_m". At the end, a list of hard 
#            lines on the plane surface (computational domain) is added
#            at the end of the GEO file.
#
#     --> p: uses a CSV file generated by the v mode in SHP2GEO.py and
#            appends to output GEO file. It reads the fields "X_m","Y_m",
#            as coordinates, "Z_m" is set to 0 (since we need a 2D mesh)
#            and the element size from "R_m". At the end, a list of hard 
#            points on the plane surface (computational domain) is added
#            at the end of the GEO file.
# 
# --> input.csv: a string that defines the path to CSV file from where the
#                geometry will be read.
#
# --> output.geo: a string that defines the path to the GEO file where the 
#                 geometrical entities will be written.                       
#
# Bibliography & Useful links:
# -- http://gmsh.info/doc/texinfo/gmsh.html#Points
# -- https://github.com/pprodano/pputils
#
#////////////////////////////////////////////////////////////////////////

import csv, sys, os, shutil

##INPUT File
pathToCSVFile = str(sys.argv[2])

##OUTPUT File
pathToGEOFile = str(sys.argv[3])

def getCommaFile(fileName, row = -1, col= -1):
    #Read csv file
    while True:
        try: 
            rawPointFile = open(fileName)
            rawPointFile = list(csv.reader(rawPointFile))
            break
        except FileNotFoundError:
            print("CSV file could not be found")

    #Return a single row
    while row != -1 and col == -1:
        try:
            return rawPointFile[row]
        except IndexError:
            print("Row could not be found")

    #Return a single column
    while row == -1 and col != -1:
        try:
            colFile=[]
            for row in range(len(rawPointFile)):
                colFile.append(rawPointFile[row][col])
            return colFile
        except IndexError:
            print("Column could not be found")

    #Return a single value
    while row != -1 and col != -1:
        try:
            return rawPointFile[row][col]
        except IndexError:
            print("Item could not be found")
def getColumn(xID):
    try:
        header = getCommaFile(pathToCSVFile,row=0)
        return(header.index(xID))
    except ValueError:
        print(str(xID) + " column could not be found")
def resetFile(nameFile):
    with open(nameFile,"w") as outFile:
        outFile.write('P=1;\nL=1;\nLL=1;\nPS=0;\n\n')
        outFile.close()
def appendFile(appendy, nameFile = pathToGEOFile):
    with open(nameFile,"a") as outFile:
        for i in range(len(appendy)):
            outFile.write(str(appendy[i]))
        outFile.close()
def buildGEOPoints(X,Y,Z=[],I=[],R=[]):
    ligne=['']
    for item in range(len(X)):
        i1 = int(I[item])
        x1 = float(X[item])
        y1 = float(Y[item])
        z1 = float(Z[item])
        r1 = float(R[item])
        ligne.append("Point(P+" + str(i1) + ") = {" \
                 + str(x1) +\
             "," + str(y1) +\
             "," + str(z1) +\
             "," + str(r1) + "};" + '\n'
                 )
    #ligne.append("\n" + "P=" + str(len(X)) + ";\n")
    return ligne
def buildGEOLines(I,L1,L2):
    ligne=['']
    for item in range(len(I)):
        i1 = int(I[item])
        l1 = int(L1[item])
        l2 = int(L2[item])
        ligne.append("Line(L+" + str(i1) + ") = {P+" \
                    + str(l1) +\
             ", P+" + str(l2) + "};" + '\n'
                 )
    #ligne.append("\n" + "L=" + str(len(I)) + ";\n")
    return ligne
def addLastIndex(parameter, quantity = 0, recursive = False):
    if recursive == False:
        indicator = str(parameter) + " = " + str(quantity) + ";\n" 
        appendFile(indicator)
    else:
        indicator = str(parameter) + " = " + str(parameter) + " + " + str(quantity) + ";\n" 
        appendFile(indicator)
    return
def setColumn(column):
    result = []
    k = 0
    for i in range(len(column)):
        if column[i] not in result :
            result.append(column[i])
            k+=1
    return result

###############################################
xColumnID = "X_m"
yColumnID = "Y_m"
iColumnID = "vertex_ind"
holeColID = "vertex_par"
paragraphSeparator = ['\n',"/**********************************/",'\n\n']
###############################################

execMode = str(sys.argv[1]).lower()

#Extract X coordinates
xCoord = getCommaFile(pathToCSVFile,col=getColumn(xColumnID))
xCoord.remove(xColumnID)

#Extract Y coordinates
yCoord = getCommaFile(pathToCSVFile,col=getColumn(yColumnID))
yCoord.remove(yColumnID)

#Extract Z coordinates #modificar?
zCoord = list(range(len(xCoord)))
for i in range(len(zCoord)):
    zCoord[i] = float(zCoord[i])*0
zCoord = list(zCoord)

#Extract Index
iCoord = getCommaFile(pathToCSVFile,col=getColumn(iColumnID))
iCoord.remove(iColumnID)

########### EXECUTION CASES ###########
# Boundary Mode 

if execMode in ["b", "boundary"]:
    rColumnID = "Rx_m"
    #Extract Refinement values
    rCoord = getCommaFile(pathToCSVFile,col=getColumn(rColumnID))
    rCoord.remove(rColumnID)

    #Extract hole flager
    holeCol = getCommaFile(pathToCSVFile,col=getColumn(holeColID))
    holeCol.remove(holeColID)
    print(str(holeCol))

    #Initialize file
    resetFile(pathToGEOFile)
    
    #Get topology
    holeListID = list(set(holeCol))
    holeListID.sort()
    
    holeIndex = []
    for hole in holeListID :
        holeIndex.append(holeCol.index(hole))
    holeIndex.append(len(holeCol))

    print(str(holeIndex))
    print(str(holeListID))
    
    for hole in range(len(holeListID)) :
        start = holeIndex[hole]
        end   = holeIndex[hole+1]-1
        GEO_Points = buildGEOPoints( \
            xCoord[start:end],\
            yCoord[start:end],\
            zCoord[start:end],\
            iCoord[start:end],\
            rCoord[start:end]\
                )
        appendFile(GEO_Points)
        
        #Convert to GEO Lines
        LINES1 = list(iCoord[start:end])
        LINES2 = list((iCoord[start+1:end]))+[iCoord[start]]
        INDEXLINES = list(range(start,end))

        GEO_Lines = buildGEOLines(INDEXLINES,LINES1,LINES2)
        appendFile(GEO_Lines)

        #Generate GEO Line Loop
        GEO_Loops = ["Line Loop (LL+" + \
            str(hole) + ") = {L+" + \
            str(min(INDEXLINES)) + " ... L+" +  \
            str(max(INDEXLINES)) + "};\n"\
                ]
        appendFile(GEO_Loops)
        appendFile(paragraphSeparator)

    #Generate GEO Plane Surface
    appendFile(paragraphSeparator)
    GEO_Surface = ["Plane Surface (PS+1) = {LL+" + \
        str(min(iCoord)) + " ... " + "LL+" + \
        str(len(holeListID)-1) + "};\n"\
            ]
    appendFile(GEO_Surface)
    
    #Update index starts
    appendFile(paragraphSeparator)
    addLastIndex("P",str(len(xCoord)),True)
    addLastIndex("L",str(max(INDEXLINES)),True)
    addLastIndex("L",str(1),True)
    addLastIndex("LL",str(hole),True)
    addLastIndex("PS",str(len(GEO_Surface)),True)
    appendFile(paragraphSeparator)

elif execMode in ["p", "pointsinsurface"]:
    rColumnID = "R_m"
    #Extract Refinement values
    rCoord = getCommaFile(pathToCSVFile,col=getColumn(rColumnID))
    rCoord.remove(rColumnID)
    
    #Convert to GEO Points   
    GEO_Points = buildGEOPoints(xCoord,yCoord,zCoord,iCoord,rCoord)
    appendFile(GEO_Points)

    #Add as points in Surface
    appendFile(paragraphSeparator)
    GEO_PointsInSurface = ["Point {P+1 ... P+" + str(max(iCoord)) +\
        "} In Surface { 1 } ;\n"]
    appendFile(GEO_PointsInSurface)
    
    #Update index starts
    appendFile(paragraphSeparator)
    addLastIndex("P",str(len(GEO_Points)),True)
    appendFile(paragraphSeparator)

elif execMode in ["l", "linesinsurface"]:
    
    lineColID = "DN"
    rColumnID = "R_m"
    #Extract Refinement values
    rCoord = getCommaFile(pathToCSVFile,col=getColumn(rColumnID))
    rCoord.remove(rColumnID)

    #Extract line identifier
    lineCol = getCommaFile(pathToCSVFile,col=getColumn(lineColID))
    lineCol.remove(lineColID)
    print(str(lineCol))

    #Get topology
    lineListID = setColumn(lineCol)
    
    lineIndex = []
    for line in lineListID :
        lineIndex.append(lineCol.index(line))
    lineIndex.append(len(lineCol))

    print(str(lineIndex))
    print(str(lineListID))
    
    for line in range(len(lineListID)) :
        start = lineIndex[line]
        end   = lineIndex[line+1] #Inclusive range []
        GEO_Points = buildGEOPoints( \
            xCoord[start:end],\
            yCoord[start:end],\
            zCoord[start:end],\
            iCoord[start:end],\
            rCoord[start:end]\
                )
        appendFile(GEO_Points)
        
        #Convert to GEO Lines

        LINES1 = list(iCoord[start:end-1])
        LINES2 = list(iCoord[start+1:end])
        INDEXLINES = list(iCoord[start:end-1])

        GEO_Lines = buildGEOLines(INDEXLINES,LINES1,LINES2)
        appendFile(GEO_Lines)

        #Add as Lines in Surface
        appendFile(paragraphSeparator)
        GEO_LinesInSurface = ["Line {L+" + str(INDEXLINES[0]) + \
            " ... L+" + str(INDEXLINES[-1]) +\
            "} In Surface { 1 } ;\n"]
        appendFile(GEO_LinesInSurface)
    
        #Update index starts
        appendFile(paragraphSeparator)
        addLastIndex("P",str(INDEXLINES[-1]),True)
        addLastIndex("P",str(2),True)
        addLastIndex("L",str(INDEXLINES[-1]),True)
        addLastIndex("L",str(1),True)
        appendFile(paragraphSeparator)
    
appendFile("//END OF BLOCK//\n\n\n")